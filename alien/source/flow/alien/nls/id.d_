module flow.alien.nls.id.legacy;
// interaction based non linear system

import std.uuid, std.traits;
import flow.base.blocks, flow.base.data, flow.base.interfaces;
import flow.data.memory;
import flow.alien.data;

private immutable string clTemplate = 
"// Pre: a<M, b<M
// Post: r=(a+b) mod M
ulong RND_AddMod64(ulong a, ulong b, ulong M)
{
	ulong v = a + b;
	if ((v >= M) || (v<a))
		v = v - M;
	return v;
}

// Pre: a<M,b<M
// Post: r=(a*b) mod M
// This could be done more efficently, but it is portable, and should
// be easy to understand. It can be replaced with any of the better
// modular multiplication algorithms (for example if you know you have
// double precision available or something).
ulong RND_MulMod64(ulong a, ulong b, ulong M)
{
	ulong r = 0;
	while (a != 0){
		if (a & 1)
			r = RND_AddMod64(r, b, M);
		b = RND_AddMod64(b, b, M);
		a = a >> 1;
	}
	return r;
}

// Pre: a<M, e>=0
// Post: r=(a^b) mod M
// This takes at most ~64^2 modular additions, so probably about 2^15 or so instructions on
// most architectures
ulong RND_PowMod64(ulong a, ulong e, ulong M)
{
	ulong sqr = a, acc = 1;
	while (e != 0){
		if (e & 1)
			acc = RND_MulMod64(acc, sqr, M);
		sqr = RND_MulMod64(sqr, sqr, M);
		e = e >> 1;
	}
	return acc;
}

uint2 RND_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance)
{
	ulong m = RND_PowMod64(A, distance, M);
	ulong x = curr.x*(ulong)A + curr.y;
	x = RND_MulMod64(x, m, M);
	return (uint2)((uint)(x / A), (uint)(x%A));
}

uint2 RND_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap)
{
	// This is an arbitrary constant for starting LCG jumping from. I didn't
	// want to start from 1, as then you end up with the two or three first values
	// being a bit poor in ones - once you've decided that, one constant is as
	// good as any another. There is no deep mathematical reason for it, I just
	// generated a random number.
	enum{ RND_BASEID = 4077358422479273989UL };

	ulong dist = streamBase + (get_global_id(0)*vecSize + vecOffset)*streamGap;
	ulong m = RND_PowMod64(A, dist, M);

	ulong x = RND_MulMod64(RND_BASEID, m, M);
	return (uint2)((uint)(x / A), (uint)(x%A));
}

//! Represents the state of a particular generator
typedef struct{ uint x; uint c; } rnd64x_state_t;

enum{ RND64X_A = 4294883355U };
enum{ RND64X_M = 18446383549859758079UL };

void RND64X_Step(rnd64x_state_t *s)
{
	uint X = s->x, C = s->c;

	uint Xn = RND64X_A*X + C;
	uint carry = (uint)(Xn<C);				// The (Xn<C) will be zero or one for scalar
	uint Cn = mad_hi(RND64X_A, X, carry);

	s->x = Xn;
	s->c = Cn;
}

void RND64X_Skip(rnd64x_state_t *s, ulong distance)
{
	uint2 tmp = RND_SkipImpl_Mod64((uint2)(s->x, s->c), RND64X_A, RND64X_M, distance);
	s->x = tmp.x;
	s->c = tmp.y;
}

void RND64X_SeedStreams(rnd64x_state_t *s, ulong baseOffset, ulong perStreamOffset)
{
	uint2 tmp = RND_SeedImpl_Mod64(RND64X_A, RND64X_M, 1, 0, baseOffset, perStreamOffset);
	s->x = tmp.x;
	s->c = tmp.y;
}

//! Return a 32-bit integer in the range [0..2^32)
uint RND64X_NextUint(rnd64x_state_t *s)
{
	uint res = s->x ^ s->c;
	RND64X_Step(s);
	return res;
}

:rawcode:

int PrepareInternal(:numbertype: tsys, :numbertype:* tsysNumberProperties, :numbertype:* debug)
{{
	int tsysType = convert_int(tsysNumberProperties[0]);

:preparecode:

	tsysNumberProperties[0] = convert_:numbertype:(tsysType);
	return 0;
}}

int CollectInternal(:numbertype: tsys, :numbertype: fsys, :numbertype:* tsysNumberProperties, :numbertype:* fsysNumberProperties, :numbertype:* tmpNumberProperties, :numbertype:* debug)
{{
	int tsysType = convert_int(tsysNumberProperties[0]);
	int fsysType = convert_int(fsysNumberProperties[0]);

:collectcode:

	tsysNumberProperties[0] = convert_:numbertype:(tsysType);
	return 0;
}}

int ModifyInternal(int tsys, :numbertype:* tsysNumberProperties, :numbertype:* debug)
{{
	int tsysType = convert_int(tsysNumberProperties[0]);

:modifycode:

	tsysNumberProperties[0] = convert_:numbertype:(tsysType);
	return 0;
}}

int InteractionInternal(:numbertype: tsys, :numbertype: fsys, :numbertype:* tsysNumberProperties, :numbertype:* fsysNumberProperties, :numbertype:* tmpNumberProperties, :numbertype:* debug)
{{
	int tsysType = convert_int(tsysNumberProperties[0]);
	int fsysType = convert_int(fsysNumberProperties[0]);

:interactioncode:

	return 0;
}}

int GetNumberIndex(int x, int y, int z)
{{
	int size = :simusize:;

	return size*size*z + size*y + x;
}}

int GetDebugIndex(int x, int y, int z)
{{
	int size = :simusize:;

	return size*size*z + size*y + x;
}}

__kernel void Prepare(__global int* errorCodeBuffer, __global :numbertype:* numberPropertiesBuffer, __global :numbertype:* debugBuffer)
{{
	if(errorCodeBuffer[0] == 0)
	{{
		int errorCode = 0;
		int tsys = get_global_id(0);

		:numbertype: tsysNumberProperties[:propertycount:];
		:numbertype: debug[:debugsize:];

		for(int i = 0; i < :propertycount:; i++)
			tsysNumberProperties[i] = numberPropertiesBuffer[GetNumberIndex(tsys, tsys, i)];

		for(int i = 0; i < :debugsize:; i++)
			debug[i] = debugBuffer[GetDebugIndex(tsys, tsys, i)];

		errorCode = PrepareInternal(convert_:numbertype:(tsys), tsysNumberProperties, debug);
	
		for(int i = 0; i < :propertycount:; i++)
			numberPropertiesBuffer[GetNumberIndex(tsys, tsys, i)] = tsysNumberProperties[i];

		for(int i = 0; i < :debugsize:; i++)
			debugBuffer[GetDebugIndex(tsys, tsys, i)] = debug[i];

		if(errorCode != 0)
			errorCodeBuffer[0] = errorCode;
	}}
}}

__kernel void Post(__global int* errorCodeBuffer, __global :numbertype:* numberPropertiesBuffer, __global :numbertype:* debugBuffer)
{{
	if(errorCodeBuffer[0] == 0)
	{{
		int errorCode = 0;
		int tsys = get_global_id(0);
	
		:numbertype: tsysNumberProperties[:propertycount:];
		:numbertype: fsysNumberProperties[:propertycount:];
		:numbertype: tmpNumberProperties[:propertycount:];
		:numbertype: debug1[:debugsize:];
		:numbertype: debug2[:debugsize:];
	
		for(int i = 0; i < :propertycount:; i++)
			tsysNumberProperties[i] = numberPropertiesBuffer[GetNumberIndex(tsys, tsys, i)];

		for(int fsys = 0; fsys < :simusize:; fsys++)
		{{
			if(tsys != fsys)
			{{
				for (int i = 0; i < :propertycount:; i++)
				{{
					fsysNumberProperties[i] = numberPropertiesBuffer[GetNumberIndex(fsys, fsys, i)];
					tmpNumberProperties[i] = numberPropertiesBuffer[GetNumberIndex(tsys, fsys, i)];
				}}
			
				for(int i = 0; i < :debugsize:; i++)
					debug1[i] = debugBuffer[GetDebugIndex(tsys, fsys, i)];

				errorCode = CollectInternal(convert_:numbertype:(tsys), convert_:numbertype:(fsys), tsysNumberProperties, fsysNumberProperties, tmpNumberProperties, debug1);

				for (int i = 0; i < :debugsize:; i++)
					debugBuffer[GetDebugIndex(tsys, fsys, i)] = debug1[i];
			}}
		}}

		for(int i = 0; i < :debugsize:; i++)
			debug2[i] = debugBuffer[GetDebugIndex(tsys, tsys, i)];

		if(errorCode == 0)
			errorCode = ModifyInternal(convert_:numbertype:(tsys), tsysNumberProperties, debug2);
	
		for(int i = 0; i < :propertycount:; i++)
			numberPropertiesBuffer[GetNumberIndex(tsys, tsys, i)] = tsysNumberProperties[i];
		
		for(int i = 0; i < :debugsize:; i++)
			debugBuffer[GetDebugIndex(tsys, tsys, i)] = debug2[i];

		if(errorCode != 0)
			errorCodeBuffer[0] = errorCode;
	}}
}}

__kernel void Interaction(__global int* errorCodeBuffer, __global :numbertype:* numberPropertiesBuffer, __global :numbertype:* debugBuffer)
{{
	if(errorCodeBuffer[0] == 0)
	{{
		int errorCode = 0;
		int tsys = get_global_id(0);
		int fsys = get_global_id(1);
	
		if(tsys != fsys)
		{{
			:numbertype: tsysNumberProperties[:propertycount:];
			:numbertype: fsysNumberProperties[:propertycount:];
			:numbertype: tmpNumberProperties[:propertycount:];
			:numbertype: debug[:debugsize:];

			for(int i = 0; i < :propertycount:; i++)
			{{
				tsysNumberProperties[i] = numberPropertiesBuffer[GetNumberIndex(tsys, tsys, i)];
				fsysNumberProperties[i] = numberPropertiesBuffer[GetNumberIndex(fsys, fsys, i)];
				tmpNumberProperties[i] = numberPropertiesBuffer[GetNumberIndex(tsys, fsys, i)];
			}}

			for(int i = 0; i < :debugsize:; i++)
				debug[i] = debugBuffer[GetDebugIndex(tsys, fsys, i)];

			errorCode = InteractionInternal(convert_:numbertype:(tsys), convert_:numbertype:(fsys), tsysNumberProperties, fsysNumberProperties, tmpNumberProperties, debug);
		
			for(int i = 0; i < :propertycount:; i++)
				numberPropertiesBuffer[GetNumberIndex(tsys, fsys, i)] = tmpNumberProperties[i];

			for(int i = 0; i < :debugsize:; i++)
				debugBuffer[GetDebugIndex(tsys, fsys, i)] = debug[i];
		}}

		if(errorCode != 0)
			errorCodeBuffer[0] = errorCode;
	}}
}}

__kernel void UploadNumberProperty(__global :numbertype:* numberPropertyTransferBuffer, __global :numbertype:* numberPropertiesBuffer, __global int* numberPropertyNum)
{{
	int tsys = get_global_id(0);

	for(int fsys = 0; fsys < :simusize:; fsys++)
	{{
		if(tsys == fsys)
			numberPropertiesBuffer[GetNumberIndex(tsys, fsys, numberPropertyNum[0])] = numberPropertyTransferBuffer[tsys];
		else
			numberPropertiesBuffer[GetNumberIndex(tsys, fsys, numberPropertyNum[0])] = 0.0;
	}}
}}

__kernel void UploadNumberArrayProperty(__global :numbertype:* numberArrayPropertyTransferBuffer, __global :numbertype:* numberPropertiesBuffer, __global int* numberPropertyNum)
{{
	int tsys = get_global_id(0);
	
	for(int fsys = 0; fsys < :simusize:; fsys++)
	{{
		numberPropertiesBuffer[GetNumberIndex(tsys, fsys, numberPropertyNum[0])] = numberArrayPropertyTransferBuffer[tsys * :propertycount: + fsys];
	}}
}}

__kernel void DownloadNumberProperty(__global :numbertype:* numberPropertyTransferBuffer, __global :numbertype:* numberPropertiesBuffer, __global int* numberPropertyNum)
{{
	int tsys = get_global_id(0);	

	numberPropertyTransferBuffer[tsys] = numberPropertiesBuffer[GetNumberIndex(tsys, tsys, numberPropertyNum[0])];
}}

__kernel void DownloadNumberArrayProperty(__global :numbertype:* numberArrayPropertyTransferBuffer, __global :numbertype:* numberPropertiesBuffer, __global int* numberPropertyNum)
{{
	int tsys = get_global_id(0);
	
	for(int fsys = 0; fsys < :simusize:; fsys++)
	{{
		numberArrayPropertyTransferBuffer[tsys * :propertycount: + fsys] = numberPropertiesBuffer[GetNumberIndex(tsys, fsys, numberPropertyNum[0])];
	}}
}}"; 

// data
class Script : IdData
{
	mixin data;

    mixin field!(string, "name");
    mixin field!(string, "code");
    mixin field!(bool, "enabled");
    mixin field!(bool, "valid");
}

class SystemScript : Script
{
	mixin data;
}

class RawScript : Script
{
	mixin data;
}

class SystemScriptMapping : Data
{
	mixin data;

    mixin field!(string, "name");
    mixin field!(uint, "order");
}

class SystemPrepareScriptMapping : SystemScriptMapping
{
	mixin data;

    mixin field!(UUID, "script");
}

class SystemInteractionScriptMapping : SystemScriptMapping
{
	mixin data;

    mixin field!(UUID, "script");
}

class SystemPostScriptMapping : SystemScriptMapping
{
	mixin data;

    mixin field!(UUID, "collectScript");
    mixin field!(UUID, "modifyScript");
}

class PropertyDescription : IdData
{
	mixin data;

    mixin field!(string, "name");
    mixin field!(bool, "array");
    mixin field!(string, "distribution");
}

class SystemDescription : IdData
{
	mixin data;

    mixin field!(string, "name");
    mixin field!(uint, "amount");
    mixin list!(SystemPrepareScriptMapping, "prepareScripts");
    mixin list!(SystemInteractionScriptMapping, "interactionScripts");
    mixin list!(SystemPostScriptMapping, "postScripts");
    mixin list!(PropertyDescription, "properties");
}

class Description : IdData
{
	mixin data;

    mixin field!(string, "name");
    mixin field!(uint, "sampleRate");
    mixin field!(uint, "obstacleMsecs");
    mixin field!(bool, "supportFp64");
    mixin field!(bool, "debugMode");
    mixin list!(SystemDescription, "systems");
    mixin list!(SystemScript, "systemScripts");
    mixin list!(RawScript, "rawScripts");
}

class Property : Data
{
	mixin data;

    mixin field!(UUID, "id");
    mixin field!(string, "name");
}

class Scalar : Property
{
	mixin data;

    mixin field!(double, "value");
}

class Array : Property
{
	mixin data;

    mixin field!(double[], "value");
}

class ScriptLine : Data
{
	mixin data;

    mixin field!(UUID, "script");
    mixin field!(ulong, "index");
    mixin field!(ulong, "debugCnt");
}

class DebugEntry : Data
{
	mixin data;

    mixin field!(ScriptLine, "line");
    mixin field!(Array, "value");
    mixin field!(ulong, "index");
}

class Compilation : IdData
{
	mixin data;

    mixin field!(string, "source");
    mixin field!(bool, "hasPrepareScripts");
    mixin field!(uint, "debugVarCnt");
    mixin list!(DebugEntry, "debugInfo");
}

class System : Data
{
	mixin data;

    mixin field!(UUID, "id");
    mixin field!(string, "name");
    mixin field!(uint, "index");
    mixin list!(Scalar, "properties");
    mixin list!(Array, "arrays");
}

class Iteration : IdData
{
	mixin data;

    mixin field!(UUID, "id");
    mixin field!(ulong, "seq");
    mixin list!(System, "systems");
}

// contexts and infos
class Context : Data
{
	mixin data;

    mixin list!(UUID, "sessions");
}

enum SessionState
{
    Casted,
    Initialized,
    Running,
    Debugging,
    Stopped,
    Disposed,
}

class SessionClMemory : Data
{
	mixin data;

    mixin field!(UUID, "errorCodeBuffer");
    mixin field!(UUID, "debugBuffer");
    mixin field!(UUID, "scalarTransferBuffer");
    mixin field!(UUID, "arrayTransferBuffer");
    mixin field!(UUID, "cnt");
    mixin field!(UUID, "buffer");
}

class SessionContext : Data
{
	mixin data;

    mixin field!(SessionState, "state");
    mixin field!(EntityPtr, "creator");
    mixin field!(EntityPtr, "owner");
    mixin field!(Description, "description");
    mixin field!(Compilation, "compilation");
    mixin field!(UUID, "clContext");
    mixin field!(SessionClMemory, "clMemory");
    mixin field!(Iteration, "actual");
    mixin list!(ComputingPlatform, "platforms");
}

class SessionInfo : Data
{
	mixin data;

    mixin field!(SessionState, "state");
    mixin field!(UUID, "description");
    mixin list!(ComputingPlatform, "platforms");
}

// tasks, entites & related
class CreateSessionSuccessMsg : Unicast{mixin signal!(SessionInfo);}
class CreateSessionFailedMsg : Unicast{mixin signal!(UUID);}
class SetSessionInitialized : Task
{
    mixin task;

    override void run()
    {
        import std.array;
        auto c = cast(SessionContext)this.entity.context;

        auto ns = new CreateSessionSuccessMsg;
        ns.data = new SessionInfo;
        ns.data.description = c.description.dataId;
        ns.data.platforms.put(c.platforms.array);
        this.send(ns, c.owner);
        c.state = SessionState.Initialized;
    }
    
    override void error(Exception e)
    {
        auto c = cast(SessionContext)this.entity.context;
        auto ns = new CreateSessionFailedMsg;
        ns.data = c.description.dataId;
        this.send(ns, c.owner);

        this.entity.process.remove(this.entity.id);
    }
}

class StartSession : Task
{
	mixin task;

	override void run()
	{
        import __flow.lib.opencl;    
        auto c = cast(SessionContext)this.entity.context;

        string[] requiredExtensions;
        if(c.description.supportFp64)
            requiredExtensions ~= "cl_khr_fp64";

        auto clContext = ClFactory.get(requiredExtensions);
        c.clContext = clContext.id;

        ComputingPlatform[] platforms; 
        foreach(p; clContext.platforms)
        {
            ComputingDevice[] devices;
            foreach(d; p.devices)
            {
                // here one could filter
                auto device = new ComputingDevice;
                device.id = d.id;
                device.name = d.name;
                device.vendor = d.vendor;
                devices ~= device;
            }

            if(devices.length > 0)
            {
                auto platform = new ComputingPlatform;
                platform.id = p.id;
                platform.name = p.name;
                platform.vendor = p.vendor;
                platform.devices.put(devices);

                platforms ~= platform;
            }
        }

        c.platforms.put(platforms);

        this.tasker.next(fqn!SetSessionInitialized); 
    }
    
    override void error(Exception e)
    {
        auto c = cast(SessionContext)this.entity.context;
        auto ns = new CreateSessionFailedMsg;
        ns.data = c.description.dataId;
        this.send(ns, c.owner);

        this.entity.process.remove(this.entity.id);
    }
}

class SessionDisposeRequest : Unicast{mixin signal!();}
class DisposeSession : Task
{
	mixin task;

	override void run()
	{
        auto c = cast(SessionContext)this.entity.context;
        this.send(new SessionDisposeRequest, c.creator); 
    }
}

class SessionInfoResponse : Unicast{mixin signal!(SessionInfo);}
class SessionInfoRequest : Unicast{mixin signal!();}
class AnswerSessionInfo : Task
{
	mixin task;

	override void run()
	{
        import std.array;
        auto s = cast(SessionInfoRequest)this.trigger;
        auto c = cast(SessionContext)this.entity.context;

        auto rs = new SessionInfoResponse;
        rs.data = new SessionInfo;
        rs.data.state = c.state;
        rs.data.description = c.description.dataId;
        rs.data.platforms.put(c.platforms.array);
        this.answer(rs);
    }
}

class Wait : Task
{
	mixin task;

	override void run()
	{
        auto c = cast(SessionContext)this.entity.context;
        import core.thread, core.time;

        Thread.sleep(c.description.obstacleMsecs.msecs);
        this.tasker.next("flow.alien.nls.id.legacy.Iterate");
    }
}

class Iterate : Task, ISync
{
	mixin task;

	override void run()
	{
        auto c = cast(SessionContext)this.entity.context;
        if(c.state == SessionState.Running || c.state == SessionState.Debugging)
        {
            // TODO execute cl kernel
            this.tasker.next(fqn!Wait);
        }
    }
    
    override void error(Exception e)
    {
        // TODO
    }
}

class RunRequest : Unicast{mixin signal!(UUID);}
class CreateClContext : Task, ISync
{
	mixin task;

	override void run()
	{
        import __flow.lib.opencl;
        auto c = cast(SessionContext)this.entity.context;
        auto s = cast(RunRequest)this.trigger;
        auto cl = ClFactory.get(c.clContext);

        cl.create(s.data);
        cl.addProgram(c.compilation.source,[
            "UploadNumberProperty",
            "UploadNumberArrayProperty",
            "DownloadNumberProperty",
            "DownloadNumberArrayProperty",
            "Prepare",
            "Interaction",
            "Post",
        ]);

        // TODO create memory objects
        //auto debugSize = c.description.debugMode ? 
        //cl.addMemory();

        c.state = c.description.debugMode
            ? SessionState.Debugging
            : SessionState.Running;

        this.tasker.next(fqn!Iterate);
    }
    
    override void error(Exception e)
    {
        // TODO
    }
}

Iteration createFirstIteration(Description d)
{
    auto i = new Iteration;

    return i;
}

class Create : Task
{
	mixin task;

	override void run()
	{
        auto c = cast(SessionContext)this.entity.context;
        c.actual = createFirstIteration(c.description);

        this.tasker.next(fqn!CreateClContext);
    }
    
    override void error(Exception e)
    {
        // TODO
    }
}

class Stop : Task
{
	mixin task;

	override void run()
	{
        auto c = cast(SessionContext)this.entity.context;
        c.state = SessionState.Stopped;
    }
    
    override void error(Exception e)
    {
        // TODO
    }
}

class StopRequest : Unicast{mixin signal!();}
class SessionInitializeRequest : Unicast{mixin signal!();}
class Session : Entity
{
    mixin entity!(SessionContext);

    mixin listen!(fqn!SessionInitializeRequest,
        (e, s) => (cast(SessionContext)e.context).state == SessionState.Casted
            ? new StartSession : null
    );
    
    mixin listen!(fqn!SessionDisposeRequest,
        (e, s) => (cast(SessionContext)e.context).state != SessionState.Disposed
            ? new DisposeSession : null
    );

    mixin listen!(fqn!SessionInfoRequest,
        (e, s) => new AnswerSessionInfo
    );
    
    mixin listen!(fqn!RunRequest,
        (e, s) => (cast(SessionContext)e.context).state == SessionState.Initialized
            ? new Create : null
    );

    mixin listen!(fqn!StopRequest,
        (e, s) => (cast(SessionContext)e.context).state == SessionState.Running
            || (cast(SessionContext)e.context).state == SessionState.Debugging
            ? new Stop : null
    );

    override void stop()
    {
        import __flow.lib.opencl;
        auto c = cast(SessionContext)this.context;
        
        if(c.clContext != UUID.init)
        {
            ClFactory.dispose(c.clContext);
            c.clContext = UUID.init;
        }
    }
}

class CreateSession : Task
{
	mixin task;

	override void run()
	{
        auto desc = cast(Description)(cast(Submit)this.trigger).data;
        auto comp = cast(Compilation)this.data;
        auto s = cast(Submit)this.trigger;
        auto c = cast(Context)this.entity.context;
    
        auto sc = new SessionContext;
        sc.owner = s.data.causer;
        sc.description = desc;
        sc.compilation = comp;

        auto session = this.entity.process.add(new Session(sc));
        c.sessions.put(session);

        this.send(new SessionInitializeRequest, this.entity.process.get(session).info.reference);
    }

    override void error(Exception e)
    {
        auto s = cast(Submit)this.trigger;
        auto ns = new CreateSessionFailedMsg;
        ns.data = (cast(Description)s.data).dataId;
        this.send(ns, s.data.causer);
    }
}

struct LineRef {UUID script; ulong line;}

private string compile(
    Script script,
    SystemDescription system,
    ulong[string] joinedProperties, 
    Description desc,
    Compilation comp)
{
    import std.conv, std.array, std.ascii, std.string;
    import std.algorithm.sorting, std.algorithm.searching;
    import std.algorithm.iteration;

    auto lines = script.code.split(newline);

    string code = "";

    foreach(li, l; lines)
    {
        string tmp;

        if(tmp.strip.startsWith("DEBUG:"))
        {
            if(desc.debugMode)
            {
                ulong debugIndex;
                auto filter = (DebugEntry d)=>d.line.script == script.dataId && d.line.index == li;
                if(!comp.debugInfo.array.any!(filter))
                {
                    auto sl = new ScriptLine;
                    sl.script = script.dataId;
                    sl.index = li;
                    auto de = new DebugEntry;
                    de.line = sl;
                    de.index = comp.debugVarCnt;
                    comp.debugInfo.put(de);

                    comp.debugVarCnt = comp.debugVarCnt + 1;

                    debugIndex = de.index;
                }
                else debugIndex = comp.debugInfo.array.filter!(filter).front.index;
                        
                tmp = l.replace("DEBUG:",
                    "debug["~debugIndex.to!string~"] =");
            }
            else tmp = "";
        }
        else if(tmp.strip.startsWith("ERROR:"))
            tmp = l.replace("ERROR:", "return ");
        else tmp = l;

        foreach(pi, p; system.properties)
        {
            auto j = joinedProperties[p.name] + 1;

            tmp = tmp.replace("tsys."~p.name,
                "tsysNumberProperties["~j.to!string~"]");
            tmp = tmp.replace("fsys."~p.name,
                "fsysNumberProperties["~j.to!string~"]");
            tmp = tmp.replace("tmp."~p.name,
                "tmpNumberProperties["~j.to!string~"]");

            tmp = tmp.replace("st.tsys", "tsysType");
            tmp = tmp.replace("st.fsys", "fsysType");

            foreach(si, s; desc.systems)
                tmp = tmp.replace("st."~s.name, si.to!string);
        }
        code ~= "\t\t"~tmp~newline;
    }

    return code;
}

private string replacePlaceHolder(
    string clTemplate,
    string numbertype,
    string rawCode,
    string prepareCode,
    string interactionCode,
    string collectCode,
    string modifyCode,
    ulong simusize,
    ulong propertyCount,
    ulong debugSize)
{
    import std.conv, std.array;

    return clTemplate
        .replace(":numbertype:", numbertype)
        .replace(":rawcode:", rawCode)
        .replace(":preparecode:", prepareCode)
        .replace(":interactioncode:", interactionCode)
        .replace(":collectcode:", collectCode)
        .replace(":modifycode:", modifyCode)
        .replace(":simusize:", simusize.to!string)
        .replace(":propertycount:", propertyCount.to!string)
        .replace(":debugsize:", debugSize.to!string);
}

// TODO just dirt ==> new identity driven nls
private Compilation compile(Description desc)
{
    import std.conv, std.array, std.ascii, std.string;
    import std.algorithm.sorting, std.algorithm.searching;
    import std.algorithm.iteration;

    auto comp = new Compilation;

    string[] prepareCodes;
    string[] interactionCodes;
    string[] collectCodes;
    string[] modifyCodes;

    ulong propertyCount;
    ulong[string] joinedProperties;

    foreach(si, s; desc.systems)
    {
        foreach(pi, p; s.properties)
            if(p.name !in joinedProperties)
                joinedProperties[p.name] = propertyCount++;

        auto prepareScripts = s.prepareScripts.array
            .sort!("a.order < b.order").array;
        auto interactionScripts = s.interactionScripts.array
            .sort!("a.order < b.order").array; 
        auto postScripts = s.postScripts.array
            .sort!("a.order < b.order").array;

        Array[][LineRef] debugInfo;
        ulong[LineRef] debugLines;
        ulong debugVarCnt;

        // compile prepare scripts
        auto prepareCode = "\tif(tsysType == "~si.to!string~")"~newline~"\t{{"~newline;
        foreach(m/*apping*/; prepareScripts.filter!(m=>m.script != UUID.init))
        {
            auto script = desc.systemScripts
                .array.filter!(ss => ss.dataId == m.script).front;
            if(script.enabled)
            {
                if(!comp.hasPrepareScripts)
                    comp.hasPrepareScripts = true;

                prepareCode ~= script.compile(s, joinedProperties, desc, comp);
            }
        }
        prepareCode ~= newline~"\t}";

        // compile interaction scripts
        auto interactionCode = "\tif(tsysType == "~si.to!string~")"~newline~"\t{{"~newline;
        foreach(m/*apping*/; interactionScripts.filter!(m=>m.script != UUID.init))
        {
            auto script = desc.systemScripts
                .array.filter!(ss => ss.dataId == m.script).front;

            if(script.enabled)
                interactionCode ~= script.compile(s, joinedProperties, desc, comp);

            interactionCode ~= "\t\t}"~newline;
        }
        interactionCode ~= newline~"\t}";

        // compile modify scripts
        auto collectCode = "\tif(tsysType == "~si.to!string~")"~newline~"\t{{"~newline;
        auto modifyCode = "\tif(tsysType == "~si.to!string~")"~newline~"t{{"~newline;
        foreach(m/*apping*/; postScripts)
        {
            if(m.collectScript != UUID.init)
            {
                auto script = desc.systemScripts
                    .array.filter!(ss => ss.dataId == m.collectScript).front;
                
                if(script.enabled)
                    collectCode ~= script.compile(s, joinedProperties, desc, comp);
            }

            if(m.modifyScript != UUID.init)
            {
                auto script = desc.systemScripts
                    .array.filter!(ss => ss.dataId == m.modifyScript).front;
                
                if(script.enabled)
                    modifyCode ~= script.compile(s, joinedProperties, desc, comp);
            }
        }

        collectCode ~= newline~"\t}";
        modifyCode ~= newline~"\t}";

        prepareCodes ~= prepareCode;
        interactionCodes ~= interactionCode;
        collectCodes ~= collectCode;
        modifyCodes ~= modifyCode;
    }

    comp.source = (desc.supportFp64 ? "#pragma OPENCL EXTENSION cl_khr_fp64 : enable"~newline~newline : "") 
        ~replacePlaceHolder(clTemplate,
            desc.supportFp64 ? "double" : "float",
            desc.rawScripts.array.map!(s=>s.code).array.join(newline~newline),
            prepareCodes.join(newline),
            interactionCodes.join(newline),
            collectCodes.join(newline),
            modifyCodes.join(newline),
            desc.systems.array.map!(s=>s.amount).sum,
            joinedProperties.length + 1,
            comp.debugVarCnt);

    return comp;
}

class CompileSuccessMsg : Unicast{mixin signal!(Compilation);}
class CompileFailedMsg : Unicast{mixin signal!(UUID);}

class Compile : Task
{
	mixin task;

	override void run()
	{
    auto s = cast(Submit)this.trigger;
    auto c = cast(Context)this.entity.context;

    auto comp = (cast(Description)s.data).compile();

    auto ns = new CompileSuccessMsg;
    ns.data = comp;
    this.send(ns, s.data.causer);

    this.tasker.next(fqn!CreateSession, comp);
    }

    override void error(Exception e)
    {
        auto s = cast(Submit)this.trigger;
        auto ns = new CompileFailedMsg;
        ns.data = (cast(Description)s.data).dataId;
        this.send(ns, s.data.causer);
    }
}

class Dispose : Task
{
	mixin task;

	override void run()
	{
        auto c = cast(Context)this.entity.context;
        auto s = cast(SessionDisposeRequest)this.trigger;

        this.entity.process.remove(s.source.id);
        c.sessions.remove(s.source.id);
    }
}

private bool holdsSession(Entity e, UUID s)
{
    import std.algorithm.searching, std.array;

    auto c = cast(Context)e.context;
    return c.sessions.array.any!(i => s == i);
}

class IdNlsCl : Entity
{
    mixin entity!(Context);

    mixin listen!(fqn!Submit,
        (e, s) => (cast(Submit)s).data.data.dataType == fqn!Description
            ? new Compile : null
    );

    mixin listen!(fqn!SessionDisposeRequest,
        (e, s) => e.holdsSession((cast(SessionDisposeRequest)s).source.id)
            ? new Dispose : null
    );

    override void stop()
    {
        auto c = cast(Context)this.context;
        foreach(s; c.sessions)
            this.process.remove(s);
    }
}